# 알고리즘 문제 회고

- **제목(번호): 햄버거 만들기 https://school.programmers.co.kr/learn/courses/30/lessons/133502**
- **카테고리: 프로그래머스**
- **회고 날짜: 2024. 9. 7.** 

## Time Limit

- 프로그래머스의 경우 따로 시간 제한을 걸지는 않음
- 대략 **1초**로 설정

## I/O Examples

| ingredient | result |
|------------|--------|
| [2, 1, 1, 2, 3, 1, 2, 3, 1] | 2 |
| [1, 3, 2, 1, 2, 1, 3, 1, 2] | 0 |


## Solution

- [👨‍💻제출 코드](solution.cc)

### 문제 핵심 개념

#### 문제 설명

- `ingredient`는 `std::vector<int>` 타입으로 `1, 2, 3` 중 하나의 값을 가진다.
- 각각 `1`: 빵, `2`: 야채, `3`: 고기 를 의미한다.
- `ingredient`에서 `1231`의 수열을 가지면 상수는 햄버거를 만든다.
- 총 몇 개의 햄버거를 만들 수 있는가?

#### 입력 값의 범위(시간 초과)

- 입력 값인 `ingredient`의 범위는 **1 이상 1,000,000 이하**의 길이를 가지고 있다.
- 즉 `O(NlogN)`안에 끝내야 한다.
- 처음 시도한 방법은 `ingredient`를 모두 `std::string`으로의 변경이었다.
- `std::string::find`와 `std::string::erase`를 이용하여 실행하였으나 시간 초과가 나버렸다.
- 당연한 결과였다. 문자 하나씩 반복 (N) 하면서 erase(최악의 경우 N)을 하면 시간 초과가 된다.

#### std::deque

- 최악의 경우 `O(N)`인 `erase`가 아닌 다른 방법을 강구해야 했다.
- `std::deque::pop_back`을 `erase`대신 쓸 수 있다.
- `std::deque::pop_back`의 경우 `O(1)`의 시간복잡도를 가진다.
- 따라서 `ingredient`가 4개 이상 되었고 차례대로 `1231`을 가질때마다 `pop_back`을 해주어 햄버거의 개수를 구할 수 있었다.

#### 시간 복잡도

- 잊고 있었던 시간 복잡도의 중요성을 알려 주는 문제였다.
- **문제에 주어진 제한 사항들을 읽으면서 어떠한 자료구조와 알고리즘을 써야 하는지 미리 생각해보고 접근하는 습관의 필요성을 느꼈다.**
